'''
Snakefile 

Authors:
Layer Lab

Adapted from supplementary materials of:

Bertolotti, Alicia C., et al. 'The structural variation landscape
in 492 Atlantic salmon genomes.' bioRxiv (2020).
'''
import os

# tell snakemake that the config file exits
configfile: 'config.yaml'

# extract the sample name. 
sample_name = os.path.basename(config['input']['forward']) \
if config['input']['sample_name'] == '' else config['input']['sample_name']

# often things are done s

rule all:
    input:
        '../temp/testLocal-indexcov/index.html',
        os.path.join(config['run']['temp_dir'], 'smoove', 'results', 'genotyped', 'localTest-smoove.genotyped.vcf.gz')
        

# indexing the reference must be done at all time
rule bwa_index_reference: 
    input:
        config['input']['reference'] 
    output: 
        os.path.join(config['run']['temp_dir'], os.path.basename(config['input']['reference']))
    params:
        prefix = os.path.join(config['run']['temp_dir'], os.path.basename(config['input']['reference']))
    log:
        os.path.join(config['run']['logs_dir'], 'bwa_index_reference.log')
    conda:
        'envs/bwa.yaml'
    shell:
        # create a symbolic link in the temp dir to the actual reference
        'ln -s {input} {params.prefix} &'
        'bwa index -p {params.prefix} {input} &> {log}' 

rule bwa_map:
    input:
        # "reverse" is a keyword internally to snakemake, so we have to shorten it to rev
        reference = rules.bwa_index_reference.output,
        forward = config['input']['samples']['forward'],
        rev = config['input']['samples']['reverse']
    output:
        os.path.join(config['run']['temp_dir'], 'mapped_reads', '{sample_name}.bam')
    params:
        rg = '@RG\\tID:{sample_name}\\tSM:{sample_name}\\tLB:lib1' 
    log:
        os.path.join(config['run']['logs_dir'], 'bwa_map_{sample_name}.log')
    conda:
        'envs/bwa.yaml'
    threads:
        # its ok if this is more threads than are available to us. Snakemake
        # does the operation: threads = min(threads, cores) so we can't go over
        threads = workflow.cores
    shell:
        '(bwa mem -R "{params.rg}" -t {threads} {input.reference}'
        ' {input.forward} {input.rev} | samtools view -Sb > {output})'
        ' 2> {log}'

rule samtools_sort:
    input:
        rules.bwa_map.output
    output:
        os.path.join(config['run']['temp_dir'], 'sorted_reads', '{sample_name}.bam')
    params:
        samtools_temp = os.path.join('sorted_reads', sample_name)
    log:
        os.path.join(config['run']['logs_dir'], 'sort_{sample_name}.log')
    conda:
        'envs/samtools.yaml'
    shell:
        'samtools sort -T {params.samtools_temp} -O bam {input} > {output} 2> {log}'

rule samtools_index:
    input:
        rules.samtools_sort.output
    output:
        os.path.join(config['run']['temp_dir'], 'sorted_reads', '{sample_name}.bam.bai')
    conda:
        'envs/samtools.yaml'
    shell:
        'samtools index {input}'

rule goleft_indexcov:
    input:
        rules.bwa_map.output
    output:
        os.path.join(config['run']['temp_dir'], '{sample_name}-indexcov', 'index.html')
    log:
        os.path.join(config['run']['logs_dir'], '{sample_name}-indexcov.log')
    conda:
        'envs/goleft.yaml'
    shell:
        'goleft indexcov -d {sample_name}-indexcov/ {input} 2> {log}'

#----------              NOTE                    ----------#
'''
In the paper, they separate the two snakefiles and call a python script in 
the middle the extract gap regions in the genome and convert to a BED file. 
That script will be integrated here. This note is so that I don't forget
'''

rule extract_gap_regions:
    input:
        config['input']['reference'] 
    output:
        os.path.join(config['run']['temp_dir'], 'output_ranges.txt')
    script:
        './scripts/extractGapRegions.py'

rule call:
    input:
        rules.samtools_sort.output
    output:
        # 'called' was originaly 'genotyped', but snakemake didn't like the ambiguity
        os.path.join(config['run']['temp_dir'], 'smoove', 'results', '{sample_name}-smoove.called.vcf.gz')
    params:
        ref = config['input']['reference']
    conda:
        'envs/smoove2.3.yaml'
    shell:
        'smoove call --outdir smoove/results/ --exclude {rules.extract_gap_regions.output}'
        ' -name {sample_name} --fasta {params.ref} -p 1 --genotype {input}'

rule genotype:
    input: 
        vcf = rules.call.output,
        bam = rules.bwa_map.output
    output:
        os.path.join(config['run']['temp_dir'], 'smoove', 'results', 'genotyped', '{sample_name}-smoove.genotyped.vcf.gz')
    params:
        ref = config['input']['reference'],
        output_dir = os.path.join('smoove', 'results', 'genotyped')
    conda:
        'envs/smoove2.3.yaml'
    shell: 
        'smoove genotype -d -x -p 1 --name {sample_name}-joint -outdir {params.output_dir}'
        ' --fasta {params.ref} --vcf {input.vcf} {input.bam}'
